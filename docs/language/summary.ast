# Astro 0.1.14a
SINGLE-LINE COMMENTS
    # Hello, World!

MULTILINE COMMENTS
    #=
    Multiline comments can span multiple lines.
    They begin with `#=`.
    #=
        They can be nested.
    =#
    And they end with `=#`.
    =#

SUBJECT BINDING
    # In Astro, subjects are names to which values or objects are bound.
    let team = 11 # The value, `11`, is bound to the subject, `team`.

    # Initialization can be deferred to later.
    let hello
    hello = 'こんにちは'

    # A subject cannot be used without binding it to a value first.
    let string
    print(string) # Invalid!

    # The `let` keyword is used for subjects whose values cannot change.
    let immutable = 10
    immutable = 50 # Invalid!

    # The `var` keyword is used for subjects whose values can change.
    var mutable = 10
    mutable = 50 # Subject value changed to 50.

    # The expression that comes after an assignment operator can be moved to the next line with a preceding indentation.
    var φ =
        arctan(y/x)

    # Multiple subjects can be assigned the same value in a single expression.
    let name id title = 'Janitor'
    cost price total = 45

SHADOWING
    # Astro allows subjects to be rebound to a different type in the same scope
    let phone = '08074789222'
    let phone = 08074789222 # `phone` rebound to an object of different type

IDENTIFIERS
    # Name of subjects must start with a character and can be followed by characters, digits or underscore.
    var my_name
    fun do_nothing(): pass

    # Astro supports wide range of unicode characters for identifiers.
    var φ = arctan(y/x)

    # Names preceded by underscores are special to the compiler.
    let _song = 'Sorry' # Invalid!

    # Naming convention.
    # Snake case for variables, constants and function names.
    let book_title = "Ender's Game"
    fun add_numbers(a, b): a + b

    # Pascal case for concrete and abstract type names.
    type InventoryManager(name, id)
    abst LightSource: SpotLight | Directional | Ambient
    type XMLParser <: Parser

    # Kebab case for module names
    import my-module { foo, bar }

    # if a name remains readable and unambiguous without underscores, then the underscores can be ommitted.
    iseven 45

VARIABLE/CONSTANT OBJECTS
    # Objects are variable by default but can be made immutable with the const keyword.
    var name = const Name('Steve')
    let list = const [1, 2, 3, 4]

FUNCTION DEFINITION (1)
    fun add(a, b): # Parameters are immutable by default.
        return a + b

    fun swap(var a, var b): # `var` keyword makes a parameter mutable.
        a, b = b, a

    # The block begin punctuator, `:`, can be replaced with `=` for single expression definitions.
    fun add(a, b) = return a + b

    # You can annotate the argument and return types of a function.
    fun modulo(a, b): #: (Int, Int) -> Int
        return a % b

    # Astro is indentation-based, but for legibility reason blocks can optionally be delimited with `..`.
    fun sub(a, b):
        a - b
    ..

COMMAND NOTATION
    # If a function call takes just one argument, the parens can be ommitted given the argument is not a list, dict, set or regex literal or preceded by a prefix operator.
    # This is necessary due to ambiguities that may otherwise be caused when parsing or reading the code.
    print "Hello"
    print name
    print 56
    print /9/
    print @set { x, y }
    print $name
    print (x, y) => x
    print {x: y | x in z}
    print [x | y in z]


    print [9] # Invalid!
    print {9} # Invalid!
    print +5 # Invalid!
    print x | y in z # Invalid!

TYPE DEFINITION (1)
    # A type is synonymous with `struct` in C. It holds the blueprint of what an object can contain.
    type Person(name, age)

    # Objects can then be created from the blueprint.
    var jane = Person('Jane Doe', 30)

DELEGATED PROPERTIES
    # Delegated properties are subjects whose assignment and access operations are delegated to specified functions.
    type Person(var name: '', var age: @delegated { age, age })

    fun age(x, v): x.age = v + 1 # Setter of delegated property must have at least two compulsory parameters.
    fun age(x): x.age + 1 # Getter of delegated property must have at least one compulsory parameters.

    john.age = 56
    john.age

    # The delegated property has only a getter, only the getter should be specified.
    type Person(var name: '', var age: @delegated { age })

    # The delegated argument can be left out if delegate functions have the same names as the delegated properties.
    type Person(var name: '', var age: @delegated)

    # A delegated property can have a default value
    type Person(var name: '', var age: @delegated { init: 12 })

EXPRESSION-ORIENTED
    # Everything (except the import and export statements) is an expression in Astro!
    var is_nypro_crazy = (fave_hobby == 'CountingBirds')

    # Type definitions, function definitions, loops, etc. all return some value.
    # In the case of a for loop, the last expression on the final iteration is returned, if there is no break.
    let cube = for i in 1..10: i³

    # The last expression of a function is always returned.
    fun add(a, b):
        a + b # The result of a + b will be returned to the caller.

    hieght = add(2, 3)

    # A semi-colon at the end of a block, stops it from returning its last value
    fun set_name(p, name): #: (Person, Str)
        p.name = name;
    ..
    let name = setname('John Smith') # Invalid! setname returns no result.

SPECIFYING TYPES
    # Types can be automatically inferred in Astro.
    var todo = 'Create a new programming language :)'

    # However you can still specify types explicitly using '#:' type comment.
    var number #: Int

    # Union types.
    var identifier #: Str | Int

    # Intersection types.
    var pegasus #: Horse & Wing

SOME BUILT-IN TYPES
    var index = UInt(2_000) # Unsigned integer type.

    let e = 2.718281828459045 # 64-bit floating-point type.

    let dog_breed = Str('German Shepherd') # Immutable UTF-8 string type.

    var list_of_groceries = ['Oranges', 'Cabbages', 'Tomatos', 'Bananas'] # List type.

    var game = 'BioShock Infinite', 2014 # Tuple type.

VALUES & REFERENCES
    # By default primitive objects (UInt, Int, Float32, Bool) are passed around by value.
    # and by default complex objects (Str, user-defined types) are passed around by reference.
    # however, you can change this behavior with 'ref' and 'val'.
    let string = "Gift"
    let number = 1000

    # Passing a complex object by value.
    var new_string = val string

    # Passing a primitive object by reference.
    var new_number = ref number

    # Astro manages memory automatically using a special reference counting technique, it handles reference cycles as well.
    my_company.affiliate = ref your_company
    your_company.affiliate = ref my_company

    # `iso` is used to hold an exclusive reference to the object.
    let developer = iso 'AppCypher'
    let another_developer = developer # Invalid!

    # While `val` is a shallow copy operation, `acq` is a deep copy operation.
    let rent = val house
    let buyer = acq game

    let player = team.player

    # An immutable reference to an object can be returned from a function using the `const` keyword.
    fun getamount(account):
        return const account.amount

NUMBER LITERALS
    # Number literals in Astro
    var index = 5 # Int literal.
    var axis = -3 # UInt literal.
    let meters = 0.25e-5 # Float64 literal.
    var price = 0x6FFF00p+12 # Hex literal.
    var op_code = 0b10110001 # Binary literal.
    var interest = 0o566768 # Octal literal.
    let salary = 10_000.f64 # a Float64 number.
    let pi = 3.14.bf # BigFloat number.

TUPLES
    # Tuple is an immutable datatype whose element types and length are determined statically.
    # Tuples cannot be appended to or removed from.
    var name, age = 'Emeka Okorafor', 27 # Open tuple.
    var game, year = ('Uncharted 4', 2016) # Closed tuple.

    # Tuple destructuring.
    let person = 'Sam', 50
    let name, age = person # name = 'Sam', age = 50
    let (name, age) = person # name = 'Sam', age = 50

    # Tuple unpacking.
    let arguments = (5, 6)
    add(...arguments)

    # Empty tuple.
    let map = ()

    # One-element tuple. Note the trailing comma.
    let map = (london,)

    # Named tuple are tuples with keys.
    let http = (status_code: 200, description: 'Ok')

    # The contents of a named tuple can be accessed using the dot notation.
    print http.status

    # Tuple indexing.
    let book = ('Harry Potter', 'J.K. Rowling', 1995)
    let title = book.1 # Harry Potter
    let author = book.2 # J.K. Rowling
    let year = book.3 # 1995

LISTS
    var unordered_list = [7, 3, 8, 5, 4, 0, 9, 1, 2, 6]

    var empty_list = []

    # Specifying a list type.
    var names #: [Str]
    var names = Str[]

    # Heterogenous list.
    var stuffs = [500, 'Steve', 1.0]

    # Astro uses 1-based indexing. Every list indices start at index 1.
    stuffs[1] # 500

    # Slicing a list.
    contestants[2:6] # 2nd to the 6th index.
    contestants[2:] # 2nd to the last index.
    contestants[:6] # first to the 6th index.
    contestants[:] # first to the last index.

    # A slice can have a step value.
    let odds = numbers[1:2:30] # The step value is the `2` in the middle.

    # Reversing a list.
    var reversed = contestants[end:-1:]
    var reversed = contestants[end:]

    # Using a constructor to create a List.
    let number = List(4, 4, '')

    fun average(students) = sum(getfield.(students, $gpa)) / students.length
    fun average(students) = students.{ getfield.($gpa).sum / length }

ARRAYS # Needs redesign work
    # Array is a supertype of List and works a bit differently from List.
    # Arrays are not preallocated and their dimension must be specified.
    # If the element type is not specified, the element type will default to F64
    let matrix = 5×5 [] # A 5 by 5 array.
    let matrix = 5*5 [] # Alternative syntax.

    # Specifying element type.
    let matrix = 5*5 Int32[]

    # Because Arrays are typically used to represent matrices.
    let a = 2×4 [
        [1, 2, 7, 8]
        [3, 4, 5, 6]
    ]

    # A 2-dimensional Array can be created using horizontal concatenation with `;`.
    let a = 2×4 [
        1, 2, 7, 8;
        3, 4, 5, 6
    ]

    # Using a constructor to create an Array.
    var matrix = Array{Int}(2, 2)

    # Setting the indices of a multi-dimensional Array.
    matrix[,] = [
        1, 6;
        3, 7
    ]

    # Multi-dimensional array slicing
    let subset = mat4[1:, 1:2]

    # Astro's lists are, by default, row-major order.
    let y = [1, 2, 3]
    # [1 2 3]

    # An Array's order can be changed using the transpose operator, `'`.
    let z = [1, 2, 3]' # Transposition'
    # [1]
    # [2]
    # [3]

    let a = [1, 2; 0, 4]

    # Array unpacking.
    let b = [
        |a', |a;
        |a,  |a'
    ]
    # [1 0 1 2]
    # [2 4 0 4]
    # [1 2 1 0]
    # [0 4 2 4]

    # Indexed integral numbers clash with array literals, so defining `getindex` on integral types is not allowed.
    # Also when multiplying by an array literal, the literal needs to be enclosed in parens.
    let result = 3×(4[])

VECTORIZATION
    # Operations can be vectorized in Astro.

    # Function calls.
    let y = div.(M, 2)

    # Prefix operators.
    let x = -.(M)

    # Postfix operators.
    let x = M.⁹

    # Infix operators.
    let z = 5 .+ M

DICTIONARIES
    # Dictionary is an associative array that stores key-value pairs.
    let game = { title: 'BioShock Infinite', year: 2014 }

    # Dictionary keys can be any valid expression.
    let parents = {
        'mum': {
            'name': 'Esther Williams'
            'age': 42
        }
    }

    # Nested dictionaries can be simplified with indentation.
    let siblings = {
        sister:
            name: 'Shade Williams'
            age: 15
    }

    # Dictionary fields can be accessed using the dot operator or the index operator.
    let mum_name = parents.mum.name
    let sister_name = siblings['sister', 'name']

    # You can also add more fields to a dictionary using the dot operator or the index operator.
    parents.mum.nationality = 'Nigerian'
    siblings.sister['nationality'] = 'Nigerian'

    # If the compiler is unsure if a field exists in a dictionary. You have to handle the possibility of nil.
    let name = parent.mum.age # Invalid!
    let name = parent.mum.age?

    # To use variable names from the outer scope as a dictionary key, the name needs to be enclosed in a bracket.
    var professor = {
        (id1): 'Charles Xavier'
        (id2): 56
    }

    # Empty dictionary.
    var empty_dict = {}

SET
    # Set is an unordered collection of items with no duplicate elements.
    let fruits = Set('orange', 'mango', 'guava', 'apple', 'orange', 'guava', 'pineapple')
    let citrus = Set('lime', 'lemon', 'orange')
    fruits.length # 4

    # Set operations.
    let union = citrus | fruits # Set('lime', 'lemon', 'orange', 'mango', 'guava', 'apple', 'pineapple')
    let intersection = citrus & fruits # Set('orange')
    let difference = citrus - fruits # Set('lime', 'lemon')

RANGE
    # Range is an iterable that allows iterating through a range of values.
    let days = 1..30 # 1 to 30

    # A range can have a step value.
    let evens = 2..2..20 # The step value is the `2` in the middle.

    # Negative step can be used to reverse the range's iteration.
    var reversed = 20..-1..1

    # Using a range in a for loop.
    for i in 1..10:
        print(i)

SPREAD OPERATOR
    # Spread takes the remaining values in a destructure.
    var a, ...b = 1, 2, 3, 4
    print(a) # 1
    print(b) # (2, 3, 4)

    # It is also used for varargs.
    fun rest(a, ...b) = print(b)

    rest(1, 2, 3, 4) # (2, 3, 4)

    # Using the spread operator with object.
    let object = { ...object, extra: 5 }

STRINGS
    let language, year = 'Astro', 2015

    # String interpolation.
    var story = "$language was started in the $year"

    # Both single and double quotes can be used to represent a string literal.
    let calc = '5 * 50 = ${5 * 50}'

    # Non-standard string literals don't have escape sequences nor interpolation.
    var verbatim_string = @raw "Use '\t' to represent tab"

    # Multiline strings are enclosed in triple `'` or `"` quotes and they ignore all escapes and interpolation
    # The first and last newlines are always ignored in multiline strings.
    var verbatim_string = '''
    Hello, World!
    '''

    # Char is 32-bit datatype that represents a single Unicode codepoint.
    var chars = char "π"

    # String operations.
    var concatenate = 'ab' + 'c' # 'abc'
    var multiply = 'ab' * 2 # 'abcabc'
    let escape_sequences = '\t \n \' \" \q \\'

    # String continuation.
    var greeting = 'Hello, ' ...
    'World!'

STRING FORMATTING
    # Padding.
    let left_padding = 'left padding: $|>10|{string}'
    let right_padding = 'right padding: $|<10|{string}'
    let placeholder_padding = 'placeholder padding: $|_<10|{string}'
    let centering = 'centering: $|^10|{string}'

    # Truncation.
    let truncating = 'truncate string: $|.10|{string}'

    # Numbers.
    let integer = 'integer: $|d|{number}'
    let float = 'float: $|f|{number}'
    let truncation = 'figure truncation: $|6.2f|{number}'
    let positive = 'positive: $|+d|{number}'
    let negative = 'negative: $|-f|{number}'

MULTILINE EXPRESSIONS
    # Expressions can be continued on the next line by ending the line with a line-continuation punctuator.
    var zero = -100 ...
    + 100

    # If an expression ends the line with a comma, it is expected to continue on the next line.
    let brother = 'James',
    'Jackcon'

    # If an expression is inside a pair of brackets, it can span multiple lines until a matching closing bracket/brace is encountered.
    let total = (1 + 2 + 3 + 4
    + 5 + 6 + 7)

    # However once the content of a parens are indented, a block is expected, so continuation punctuator is needed for incomplete expression.
    let total = (
        1 + 2 + 3 + 4 ...
        + 5 + 6 + 7
    )

    # Chained dot notation can be written on subsequent lines but with an indentation.
    sentence
        .trim()
        .lower()

CASCADING NOTATION
    # Cascading notation can be used to reduce common operand repetition.
    let fullname = james.firstname + james.middlename + james.lastname
    let fullname = james.{ firstname + middlename + lastname }

    if john.firstname.length == john.lastname.length: bar()
    if john.{ firstname == lastname }.length: bar()

    # Cascading notation also allows you to assign values to multiple properties of an object.
    first.name = second.name
    first.age = second.age
    first.{ name, age } = second

    # Cascading on function call, indexing and field access.
    array.push!(x), \(y)
    array[x], \[y], \[z] = 1, 2, 3
    print(john.name, \age) # John 40

PASS KEYWORD
    # `pass` keyword can used to represent an empty block.
    fun div(a, b): pass

INDENTATION
    # Astro recognizes 4-space indentations only. No tabs.
    fun removespaces(string):
        return s.split(/\s/).join()

    fun removespaces(string):
      return s.split(/\s/).join() # Invalid!

IF EXPRESSION
    # Coonditional branches using `if`, `elif` and `else`.
    if is_adrian_rich:
        spendall('on parties')
    elif is_orobo_rich:
        spendall('on legos')
    else:
        cry('we are broke')

    # Checking for nil.
    if phone_number: # The block executes if `phone_number` is not nil.
        call(phone_number)

    # Checking for nil and binding value to a subject.
    if let stock_code = get_stock_code('APPLE'):
        print('APPLE: $stock_code')

TERNARY OPERATOR
    # The ternary operator is a syntactic sugar for an if-else expression.
    let cmp = if a > b: 0 else: 1

    # Astro requires parens around the condition.
    let cmp = (a > b) ? 0 : 1

NIL
    # Sometimes, it can be useful to represent an empty or a missing state.
    # This can be achieved with nils in Astro.
    # Non-nillable subjects can give nil nor be assigned a nil value.
    var password = '#5Nj%4VpA391w' #: Str
    password = nil # Invalid!

    # Nillable object can be assigned nil.
    var program = 'print(\"Hello World\")' #: Str|Nil
    var program_list = Str()?

    # Nillable unwrap.
    let name = dave.name?

    # Exceptionable unwrap.
    !getaccount("Default") # If result is nil, NilError is raised.

    # Examples
    james.relative.sister?
    !james.relative.sister
    (!james.relative).sister?

    # Nil coalescing.
    let name = getname() ?? "John Doe"

BOOLEAN OPERATORS
    # `and`, `or`, `not` operators
    x == y and x == z
    not (x == y)
    name not in list

    # Astro also allows math-like boolean operator chaining.
    a == b and b == c # Can be rewritten as.
    a == b == c # Same as above.

FOR LOOP
    # A `for` loop iterates through an iterable and binds the value to a subject.
    for i in 1..11:
        print i

    # Destructuring in loop.
    for kind, number in interesting_numbers:
        print '$kind: $number'

    # By default the for loop subjects are immutable, but they can be made mutable using the `var` keyword.
    for var i in 1..20:
        i += 1
        j = i
    ..

    # A `for` loop can be extended with a `where` condiition.
    for i in array where i == 5:
        return i

    # The `else` block executes when a loop completes without interruption from `break`, `return` or `throw`.
    for line in file where /lagbaja/ in line:
        print "name found!"
        break
    else:
        print "name not found!"

COMPREHENSION
    # Comprehensions are syntactic sugar for iterator generators.
    let gen = i | i in random(0, 200)

    # Extending a comprehension with `where`.
    let list = list(x | x in 1..21 where x mod 2 != 0)

    # List comprehension
    let list = [x | x in 1..21 where x mod 2 != 0]

    # Dictionary comprehension
    let dict =  { i: i² | i in arr1 }

    # Set comprehension.
    let set = set(i | i in random(0, 200))

    # Nested loops.
    let dict = { x: y | x in 1..30; y in 31..60 where even(y) }

BREAK WITH
    # Break-with breaks a loop and returns a value.
    for name in register where name == 'Tony':
        break name
    else: ""

IN
    # `in` is a special keyword-based infix operator that checks for the existence of an object in a collection type.
    if student.name in defaulterlist:
        print '${student.name} hasn\'t paid yet. Contact parents'

    # Negation.
    if 'ps4' not in birthday_presents:
        print 'Aaargh! Everyone hates me'

    # Regex matching.
    if /dollar[s]?/ in sentence:
        sentence.replace(/dollar[s]?/, 'pounds')

MOD
    # `mod` is a keyword-based infix operator alias of `%` operator.
    fun iseven(n) = (n mod 2 == 0)

CHAINED CONDITIONAL CONSTRUCTS
    # It is idiomatic in Astro to put, at most, two nested conditional constructs on the same line where possible.
    if person in audition_roster: if person.mark > 40.0:
        acceptance_list.add person

    # It can significantly reduce the number of indentations.
    fun any_common_elements(l, r):
        for i in l: for j in r where i == j:
            return true
        false

WHILE LOOP & LOOP
    # Conditional loop.
    while file.has_next():
        print file.next()

    # Unconditional loop. Synonymous to `while true`.
    loop: # Note, `loop` is not a reserved keyword.
        let input = scan '>>> '
        let tokens = lex input
        let ast = parse tokens
        let bytecodes = compile ast
        let result = interpret bytecodes
        print result

    # A do-while loop block is evaluated at least once.
    do: # Note, `do` is not a reserved keyword.
        print x
        x += 1
    while x < 50

    # Nillable assignment in while loop.
    while let details = books[title]:
        print details
        if details.author != 'J.K. Rowlings':
            break
        title = choose_title_randomly()
    ..

    # Like `for` loops, `while` and `loop` can have a closing `end` block.
    while file.has_next() where /\t+/ in file.next():
        break 'File contains tabs!'
    else: 'File is clean!'

MATCH EXPRESSION
    # Match expression is like a chain of if-elif-else expressions.
    # If a match pattern fails, it goes to the next pattern.
    object
    | { x, y } :: Some => 0 # Matches if object is of `Some` type.
    | { x: 2, y: 3 } :: Some => 0 # Matches if object is of `Some` type.
    | [1, 2, ...s] => 0 # Matches if object is a list or an array that has values `1`, and `2` at beginning.
    | (x, y) => x # Matches if object is a tuple of two elements.
    | 75 or 90 => 3 # Matches if object has a value `75` or `67`
    | 75 to 90 => 3 # Matches if object has a value between `75` and value `67`
    | 75 => spill # `spill` keyword means the control flow should unconditionaly move to the next match condition.
    | n => 6 # Matches. Binds `n` to the object.
    | _ => 7 # Matches.

    # A match expression can also be used to match against the arguments of a function, if, for, loop or while expressions.
    fun ischosen(option):
        | 'y' or 'Y' => true
        | 'n' or 'N' => false
        | _ => raise Error('Invalid choice!')

ASSIGNMENT DESTRUCTURING
    # Instead of separately binding subjects to objects fields, it can be done in a single expression with destructuring.
    let name = person.name
    let age = person.age
    let { name, age } = person

    # Destructuring patterns for other data structures
    let [name, age, _, ...rest] = [1, 2, 3, 4, 5]
    let (a, b, _, ...c) = (1, 2, 3, 4, 5)
    let a, b, c = (1, 2, 3, 4, 5)

SCOPE LABELLING
    # Labels allow the programmer to specify the conditional block to break, yield, return, etc. to.
    for line in file: @(outer)
        for c in line where c == '\t':
            break @outer # breaks the outer loop
    ..

MAIN FUNCTION
    # If a module contains a main function, it will be the module's entry point.
    fun main():
        print 'Hello World!'

FUNCTION DEFINITION (2)
    # If a function returns nothing, it can either be annotated with None or left empty.
    fun show(point): #: (Point) -> None
        print(point.{ a, b })

    # The normal order of arguments in a function call can be changed if the parameter name is specified.
    fun say(msg, name): #: (Str, Str)
        print '$msg $name!'
    ..
    say(name: 'Steve', 'Hello') # Hello Steve!

    # Varargs takes variable number of arguments.
    fun arith_mean(...numbers):
        var total = 0
        for number in numbers:
            total += number
        total / numbers.length
    ..
    arith_mean(1, 2, 3, 4) # It can take multiple arguments.
    arith_mean(...tuple) # Or a spread tuple.

    # Anonymous functions are functions without names.
    fun _(): return a + b

    # Default parameter values.
    fun login(username: 'demo', password: 'demo'):
        access Account(username, password)
    ..
    login() # Using default values.

    # Compulsory named parameters are marked with `.`.
    fun signup(username., password.):
        access Account(username, password)

    # The parameter names must be specified in the function calls.
    signup(username: 'appcypher', password: 'bazinga!')
    signup('appcypher', 'bazinga!') # Invalid!

    # Compulsory named parameters can have a different name that can be used within the function block.
    fun send(message, to.recipient):
        print((message + recipient).upper())
    ..
    send('Hello', to:'Cantell')

    # Compulsory named can also be used with varargs, which would then be a named tuple.
    fun total(start, ...rest.):
        let result = start
        for i in rest: result += i
        result
    ..
    total(0, watch: 500, shoes: 6700, laptop: 1200)

    # Destructuring parameters.
    fun show({name, age}) = print(name, age)

    # A function's arguments can be accessed as a named tuple via _args.
    fun printperson(name, age) = print(_args)
    printperson('John', 25) # (name: 'John', age: 25)

    # Astro supports Unified Function Call Syntax (UFCS), so a function can be called with using the dot notation.
    print(500)
    500.print()

MUTATIVE FUNCTIONS
    # Mutative functions are functions that mutate the arguments passed to them.
    # Astro supports overloading of functions based on argument mutation.
    fun reverse(iterable):
        let reversed = @cast(List) {
            buffer: malloc{iterable.type.T}(iterable.length)
            length: @delegated { length: iterable.length }
            capacity: 10
        }
        for i, e in enumerate iterable:
            reversed[end + 1 - i] = e
        reversed

    fun reverse(var iterable):
        let mid = iterable.middleindex
        for var i, e in iterable[:mid]:
            let temp = iterable[end + 1 - i]
            e = temp
        pass

    let reversed = reverse(list) # Calls the first `reverse`
    let reversed = reverse!(list) # Calls the second `reverse`

LAMBDAS
    # Functions are first-class objects and can be passed around just like regular objects.
    let scores_extra_marks = scores.map(fun _(score): score + 5)
    scores.each(print)

    # Assigning a function to a subject.
    let add = +
    add(4, 5) # 9

    # Lambdas are syntactic sugar for anonymous functions.
    fixture_list.filter(fun _(game): not game.iscancelled) # Anonymous function.
    fixture_list.filter((game) => not game.iscancelled) # Lambda.

    # When a function call takes a single function argument, the lambda can be written after the call parens.
    list.foldl(0, (x, y) => x + y)

    # If a lambda takes a single argument, the parethenses can be ommitted.
    list.each(x => print(x))

    # Recursive lambda.
    # An anonymous function or lambda can be recursively called within its body using the `_(...)`.
    list.aggregate((0, a) => (a == 0) ? 1 : a + _(a - 1))

    # Immediately-invoked function.
    ((a, b) => a + b)(2, 3)

CLOSURE
    # A closure is a function defined within another function.
    fun gen_db_connector(host., username., password.):
        return fun make_db_conection(): # A closure can aslo be returned.
            db.connect(host, username, password)
    ..

PARTIAL APPLICATION
    # Partially applied functions are function calls with one or more of their argument not applied.
    fun multiply(a, b) = a × b

    # Unapplied arguments are represented with the placeholder, `$`.
    let multiply3by = multiply(3, _)

    # Applying missing arguments.
    multiply(3, _)(5) # 15
    multiply3by(5) # 15

COROUTINES
    # A coroutine is a type of function that can pause and resume its execution.
    # `yield` marks an execution pause and resumption point.
    fun count(num):
        for x in ..num: yield x

    # Instantiating the coroutine.
    var counter = count(25)

    # Calling the coroutine.
    count.next() # 0
    count.next() # 1
    count.next() # 2

    # `yield from` redirects a coroutine through another coroutine.
    yield from coroutine

TYPE DEFINITION (2)
    # Defining a type.
    type Car:
        var make
        var year

    # The block begin punctuator, `:`, can be replaced with `=` for single expression definitions.
    type Car = var make, year

    # Types need constructors for object creation. A constructor always has the same name as the type.
    # The special `new` syntax creates a new object of the particular type.
    fun Car(make, year):
        new { make, year }
        print(self) #: self can be used to refer to the object in creation.

    let ride = Car('Camaro', 2016)

    # Constructors containing `new` keyword cannot be defined outside the module the original type is defined in.

    # A constructor that contains just a `new` function call can be shortened like this.
    fun Car(maker, year)

    # Constructor types are a syntax sugar for merging type and corresponding constructor definitions together.
    type Car(var make, var year)
    let ride = Car('Camaro', 2016)

    # On the other hand, a type can have a destructor.
    # Destructor can be used for last-nanosecond cleanups before an object is destroyed.
    # The object can be referenced in the destructor body with `self`
    fun Car(!) = print('deleting car: ', self.{ make, year })

GENERICS
    # Uppercase single letter identifiers in type annotation are taken as type variable declaration.
    # Declaring a generic type T.
    fun add(a, b): #: (T, T) -> T
        print T
        return a + b

    # Specifying generic type constraint with `where` and type relation operators (`::`, `<:`, `>:`)
    fun any_common_elements(l, r): #: (T, U) -> Bool where |T, U| <: Sequence
        for x in l: for y in r where x == y:
            return true
        false

    #: C, D -> Bool
    #: where |C, D| <: Collection,
    #: where C.Element::D.Element
    #: where C.Element<:Equatable
    fun startequal(c, d): c.first == d.first

    # `_` is placeholder for type parameters that should be inferred by the compiler.
    #: (Seq, _) -> T where T::Seq.T
    fun getitem(list, index):
        list[index]

    # Types and functions can have generic type parameters and the parameters can have default values.
    type Buffer: #: {T: Any}
        var buffer

    fun Buffer(length): #: {T} (Int)
        new { buffer: malloc{T}(length) }

    let buf = Buffer{Int}(50)

    # Nillable type annotation.
    let language #: Str|Nil
    let language #: Str?

    # List type annotation.
    let languages #: List{Str}
    let languages #: [Str]

TYPES AS FIRST-CLASS CITIZENS
    # Types can be passed around and specialized on like regular objects in Astro.
    Int64 :: Type{Int64}
    Int64 :: Type

    # Having type be objects themselves allows us to overload functions based on the type of a type
    fun zero(t) = 0.0 #: Type{Float}
    fun zero(t) = 0 #: Type{Int}

    zero(Float) # 0.0
    zero(Int) # 0

TYPE CONVERSION
    # In Astro, the lowercase version of type names are usually meant for type conversion operations.
    var three = int(3.14159265358) # Converts `3.14159265358` to an Int
    var five = str(5) # Converts `5` to a Str
    var uniques = set([1, 2, 3, 4, 5, 4, 3, 7]) # Converts a list to a set

INHERITANCE
    # Types can inherit from one or more parent types in Astro.
    type Person
    type Parent1 <: Person # Parent1 type inherits fields from Person.
    type Parent2 <: Person  # Parent2 type inherits fields from Person.

    # Multiple inheritance is allowed as well.
    type Child <: Parent1, Parent2  # inherits Parent1, Parent2.

    # Astro has ways of resolving diamond problems, dicussed in "Method Ambiguities" and "Constructor Train"
    # below, but it is advised to use composition where inheritance does not make sense.
    type Car <: Engine #: This makes no sense, a `Car` is not an `Engine`
    type Car = let engine #: This makes sense, a `Car` can have an `Engine`

MULTIPLE DISPATCH
    # Astro uses a covariant multiple dispatch to resolve function calls.
    # The most specific function is always called based on the number and types of arguments passed.
    fun foo(a, b) = print('generic') #: (Int32, Real)
    fun foo(a, b) = print('specific') #: (Int32, Int32)

    foo(4, 5.0) # generic
    foo(4, 5) # specific

    # The compiler can be made to call a less specific version of a function using the `as` keyword.
    foo(4, 5 as Real) # generic

METHOD AMBIGUITIES
    # There are some ambiguities that can arise in multiple inheritance and multiple dispatch.
    # Ambiguity error is thrown when a type inherits from types that have different specific implementations of function.
    fun speak(parent1) = print('mom!') #: Parent1
    fun speak(parent2) = print('dad!') #: Parent2
    type Child <: Parent1, Parent2 # Error!

    # To resolve this issue, the `sound` function need to be overloaded for `Child` type.
    fun speak(child) = print('child!') #: Child

    # Ambiguity error is also thrown when the arrangement of type paramters causes multiple dispatch ambiguity.
    fun foo(a, b) = print('fizz') #: (Int32, Real)
    fun foo(a, b) = print('buzz') #: (Real, Int32)
    foo(1, 2) # Error!

    # A more specific function need to be provided
    fun foo(a, b) = print('fizz') #: (Int32, Int32)

CONSTRUCTOR TRAIN
    # Astro follows the principle where each type is responsible for the initialisation of fields it introduces to the type hierarchy.
    # Constructor train is Astro's way of ensuring declared and inherited fields of a particular type are initialized on object creation.
    type Person(name)
    type Teacher(subject) <: Person
    type Student(course) <: Person

    # The initialization of inherited fields should be delegated to the parent's constructor.
    fun Teacher(name, subject) = new { subject }.Person(name)

    # In the case of multiple inheritance, the individual parent constructors are called and chained to the `new` syntax.
    type TeachingStudent(schedule) <: Teacher, Student
    fun TeachingStudent(name, subject, course, schedule):
        new { schedule }.Student(name, course).Teacher(_, subject)

ABSTRACT TYPES & FUNCTIONS
    # Abstract types cannot be instantiated.
    abst Player
    var p = Player() #: Error!

    # A function without a body is an abstract function and an error will be raised if called directly.
    fun rewind(player) #: Player
    rewind(p) #: Error!

    # An abstract type can have fields.
    abst Human(name, age)
    abst Human = var name, age

    # Abstract types can have subtypes declared within them effectively making them algebraic data types.
    abst Tree:
        | Leaf(value) #: (T) -> Leaf
        | Node(l, r) #: (Leaf, Tree) -> Node

    # If both fields and subtypes needs to be declared, the declarations can be separated.
    abst Animal = var name
    abst Animal = Dog | Cat | Parrot

TYPE EXTENSION
    # Existing types can be extended in Astro using the `extend` macro
    @extend
    type Integer:
        let f64 = @delegated { float64 }

CUSTOM PRIMITIVE TYPES
    # Primitive types are value types that are stored and interpreted as machine-intrinsic types like Int and Float64.
    # A Primitive type can be created using the `primitive` macro.
    @primitive(Int64) # the type instance will be stored and interpreted as an Int64
    type Numeral(num)

TYPE ASSERTION
    # The `typeof` operator can be used to get an object's type.
    typeof 50 # Int32

    # `::`, `>:`  and `>:` are operators for asserting type relations.
    50 :: Integer # Exact type assertion.
    50 <: Integer # Subtype assertion.
    50 >: Integer # Supertype assertion.

    # A more complex type assertion.
    head([1, 2, 3]) :: ([Int]) -> Int

TYPE ALIASES
    # A single or set of types can be given an alias
    type Number = Integer | Float | Complex
    fun add(a, b) = a + b #: (Number, Number) -> Number

CAST FUNCTION
    # `cast` is a special macro in Astro, because it can turn a dictionary into a typed object.
    let reversed = @cast(List) {
        buffer: malloc{list.T}(list.length)
        length: @delegated { length }
    }

    # It can also change how a value type is interpreted.
    let value = @cast(Int64) 1.0
    let value = @cast(Float64) 1.i8

REFERENCE EQUALITY
    # `is` operator can be used check if two operands refer to the same object representation.
    let a = 'Hi'
    let b = 'Hey'
    let c = a
    a is b # false
    a is c # true

MODULES & IMPORT
    # Importing a module.
    import quaternion
    let quat = quaternion.mat2quat([1, 2; 3, 4])

    # Exported members of a module can be imported directly into the current namespace.
    import quaternion { mat2quat }
    let quat = mat2quat([1, 2; 3, 4])

    # Importing all exported members of a module.
    import math {...}

    # Importing multiple modules
    import csv, dataframes

    # Module path can be specified following the Unix style. In that case, they need to be enclosed in quotes.
    import 'nypro/../my-cool-project'

    # Renaming can help disambiguate imports.
    import fastmath: 'nypro/fast-math' { cosine: cos, sine: sin, π: pi }
    let b = fastmath.tan(45)
    let d = cosine(30)

    # Importing all except some members.
    import math {...} except { sin, cos }

    # Aggregate module
    # A single module can be split between different files by numbering them.
    # `vector.ast`, `vector-1.ast`, `vector-2.ast`, etc. all combine as a single module.
    import vector

EXPORT
    # Subjects, functions and types declared within the current module can be exported using the 'export' keyword.
    export { cos, sin, tan }

    # There can only be one export statement in a module.
    import random { randoms }
    fun random_string() = randoms(10).map str
    export random_string

    # Exporting all except some members.
    export {...} except { sin, cos }

PRIVATE ACCESS MODIFIER FOR FIELDS
    # When a type is exported, its fields are made public by default.
    # To prevent a field from exposure to external modules, it must be marked with `*`.
    type Student:
        var name
        var scores* # field is private to module

    type Student(name, scores*)

OPERATORS
    # Operators are special characters (+-/\&|=%$ ...) and can be combined to form new names.
    # Operators are different from regular identifiers in the way they are used. There are:
    # Prefix operators, with the operator preceding its operand.
    let negation = +500

    # Postfix operators, with the operator coming directly after its operand.
    let squared = 4²

    # Infix operators, with the operator in-between two operands.
    let addition = 5 + 8

    # Operators and Spacing.
    # Prefix or postfix operators cannot have spaces between them and the operand.
    let negation = + 500 # Invalid!
    let squared = 4 ² # Invalid!

    # An infix operator can either have spaces on both sides or not have spaces at all.
    let addition = 5+8
    let addition = 5 + 8
    let addition = 5 +8 # Invalid!
    let addition = 5+ 8 # Invalid!

    # Operators cannot be combined with normal identifiers or special characters/punctuators like .,`@(){}[] to form new names.
    let pl*s = 5 # Invalid!

OPERATOR OVERLOADING & CUSTOM OPERATOR
    # Existing operators can be overloaded just like regular functions.
    fun +(x, y): #: (Dual, Dual) -> Dual
        Dual({ x + y }.vl, { x + y }.adj)

    # New operators can also be created by combining operators as a name.
    fun ++(x): #: (Real, Real) -> Real
        var temp = val x
        x += 1
        return temp

    # Special operators like [] and {} can be overloaded using their alternative identifier names.
    fun getindex(sequence, index): #: (Sequence, Signed) -> T
        return sequence.items[index]

TRY, EXCEPT & ENSURE
    # Raising an exception with the `raise` keyword.
    if numerator & denominator == 0:
        raise DomainError('division by zero!')

    # Handling an exception
    # Ensure block is optional, but when it is present, it is always run.
    try:
        process big_data
    except IncompleteDataError:
        print error.message # the error object can always accessed in `except` block.
    ensure:
        restore big_data

    # The except body can be ommitted if it's only printing the error message.
    try: process big_data
    except IncompleteDataError

    # A single except can catch mutiple error types.
    try: process big_data
    except IncompleteDataError, CorruptDataError

    # An object defined in the try's header always has it's at the end of the try block.
    try file = open('dancing-masquerade.txt'):
        for line in file: print line

SYMBOL
    # Symbols are static data types that hold their content as-is.
    let symbol = ${2 + 3}

    # A symbol can be interpolated with another symbol using back ticks.
    let addition = ${let five = $symbol}

    # A symbol can be evaluated with the 'eval' keyword.
    eval addition

REGEX
    # Regex are used to find and/or capture patterns in strings.
    var number_pattern = /\d+(.\d+)?/
    number_pattern in 'π = 3.14159265' # true

    # Regex operations.
    var = /\d/ + /[a-z]/ + /\d/ # Concatenation

COEFFICIENT EXPRESSION
    # Coefficient expression as the name implies allows coefficients to be taken as multiplication.
    let x = 3 * f + 2 * (6 + 1)
    let x = (3)f + 2(6 + 1)
    let x = 3f + 2(6 + 1)

    # Because of this syntactic sugar, Numeric types cannot be made callable.
    fun call(i, ...args) = i + sum(args) #: (Int, [Int]) -> Int # Invalid!

    # Note: In the case of hex literal, coefficient expressions are not permitted.
    let h = 0x344f # f is not considered a variable here, but part of the hex literal.
    let h = 0x344j # Invalid!
    let h = (0x344)f

INTEGER BITWISE OPERATORS
    # Bitwise `or` changes the bit to `1` if the corresponding bit in either operand is `1`.
    var x = 2 | 5

    # Bitwise `and` changes the bit to `1` if the corresponding bits in both operands are `1`.
    var y = 3 & 6

    # Bitwise `not` Inverts the bits of its operand.
    var z = ~6

    # Bitwise `xor` changes the bit to `1` if corresponding bits in operands are not both `1`.
    var a = 5 ~ 7

    # Bitwise `left shift` moves the bits in `a` to the left `b` times.
    var b = a << b

    # Bitwise `right shift` (sign propagation) moves the bits in `a` to the right `b` times.
    # It shifts in the sign bit from the left.
    var c = b >> a

    # Bitwise `right shift` (zero propagation) moves the bits in `a` to the left `b` times.
    # It shifts in the `0`s from the left.
    var c = b >>> a

POINTERS
    # Creating a pointer to a primitive object address.
    let num = 55
    let pointer = ptr(num)

    # Changing value of pointed address.
    pointer.value = 57

    # Changing pointer address is not permitted.
    pointer.addr = 0xFFFE # Invalid!

    # Allocating memory on the heap.
    let memory = malloc{Byte}(5) # Allocates 5 bytes on the heap.

    # Freeing memory.
    free(memory) # Compile-time error will be thrown if there is a possible dangling pointer.

    # Pointer arithmetic is only allowed on pointers that point to a block of memory and such operations are always bounds-checked.
    let memory = malloc{Int}(20)
    let pointer = memory[2]
    pointer.offset(5)
    pointer.offset(500) # Error!

RESERVED KEYWORDS
    import, export, let, var, const, fun, type, abst, async,
    ref, val, iso, acq,
    if, elif, else, while, for, try, except, ensure, defer, loop, end,
    spill, return, raise, break, continue, yield, from, await,
    where, at,
    is, not, in, as, mod, typeof,
    new,

PREDEFINED TYPE HIERARCHY
    Type
    Any
        Function
        Scalar
            Real
                Integer
                    Signed
                        Int, Int8, Int16, Int32, Int64,
                    Unsigned
                        UInt, UInt8, UInt16, UInt32, UInt64
                Float
                    Float32, Float64
            Complex
                Complex64, Complex128
            Bool
        Seq
            List
            Array
            Set
            Range
            Indexer
            Tuple
            NamedTuple
            Dict
            Coroutine
